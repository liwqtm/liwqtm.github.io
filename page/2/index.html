<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.11.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="苦心人天不负">
<meta property="og:type" content="website">
<meta property="og:title" content="茯楚博客">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="茯楚博客">
<meta property="og:description" content="苦心人天不负">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="李万青">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/2/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>茯楚博客</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">茯楚博客</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">记录整理技术文章</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="李万青"
      src="/images/8a06cd0a8da6a6848b7a0b37b32164b7.jpeg">
  <p class="site-author-name" itemprop="name">李万青</p>
  <div class="site-description" itemprop="description">苦心人天不负</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/liwqtm/liwqtm.github.io" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;liwqtm&#x2F;liwqtm.github.io" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:Lwq1006317864@outlook.com" title="E-Mail → mailto:Lwq1006317864@outlook.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/qq_39339965?type=blog" title="我的CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_39339965?type&#x3D;blog" rel="noopener" target="_blank"><i class="fab fa-superpowers fa-fw"></i>我的CSDN</a>
      </span>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://blog.csdn.net/m0_51464746?type=blog" title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;m0_51464746?type&#x3D;blog" rel="noopener" target="_blank">张怀猛的博客</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/14/Spring%20IOC-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/8a06cd0a8da6a6848b7a0b37b32164b7.jpeg">
      <meta itemprop="name" content="李万青">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茯楚博客">
      <meta itemprop="description" content="苦心人天不负">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 茯楚博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/14/Spring%20IOC-3/" class="post-title-link" itemprop="url">IOC流程解析-BeanFactoyPostProcessor和BeanPostProcessor</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-14 00:00:00" itemprop="dateCreated datePublished" datetime="2022-03-14T00:00:00+08:00">2022-03-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-05-30 12:53:05" itemprop="dateModified" datetime="2022-05-30T12:53:05+08:00">2022-05-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">Java框架</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java%E6%A1%86%E6%9E%B6/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本次内容要讲的是BeanFactory 创建完成并设置了BeanDefinition 之后，BeanFactoyPostProcessor 的初始化和执行，还有BeanPostProcessor 的初始化，注意今天的内容BeanPostProcessor 是不会执行的，在  <a target="_blank" rel="noopener" href="https://liwqtm.github.io/2022/03/09/Spring%20IOC-1/#more">Spring的基本概念和IOC流程的简述</a> 的文章就说过了IOC 的流程图，BeanPostProcessor 的执行是在Bean 实例化之后。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>接着上篇文章（上篇文章是：  <a target="_blank" rel="noopener" href="https://liwqtm.github.io/2022/03/11/Spring%20IOC-2/#more">IOC流程解析-BeanFactory的创建</a>）继续讲IOC 的核心方法refresh 方法的内容，之前讲完了obtainFreshBeanFactory 方法的调用，那么下一步就是prepareBeanFactory 方法了。
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/03/14/Spring%20IOC-3/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/11/Spring%20IOC-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/8a06cd0a8da6a6848b7a0b37b32164b7.jpeg">
      <meta itemprop="name" content="李万青">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茯楚博客">
      <meta itemprop="description" content="苦心人天不负">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 茯楚博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/11/Spring%20IOC-2/" class="post-title-link" itemprop="url">IOC流程解析-BeanFactory的创建</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-11 00:00:00" itemprop="dateCreated datePublished" datetime="2022-03-11T00:00:00+08:00">2022-03-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-05-30 12:53:07" itemprop="dateModified" datetime="2022-05-30T12:53:07+08:00">2022-05-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">Java框架</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java%E6%A1%86%E6%9E%B6/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本次内容的重点是BeanFactory 的创建、BeanDefinition 的构建以及配置文件的解析、还有Schema 机制分析（这里要结合dubbo 的一点点内容，对于dubbo 有一定了解的小伙伴可以看下，没有的话建议跳过，后面看dubbo 的时候在回来看这个内容）。
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/03/11/Spring%20IOC-2/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/20/Dubbo-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/8a06cd0a8da6a6848b7a0b37b32164b7.jpeg">
      <meta itemprop="name" content="李万青">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茯楚博客">
      <meta itemprop="description" content="苦心人天不负">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 茯楚博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/02/20/Dubbo-1/" class="post-title-link" itemprop="url">Dubbo源码分析-SPI机制流程分析及核心架构图解析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-20 16:40:27" itemprop="dateCreated datePublished" datetime="2022-02-20T16:40:27+08:00">2022-02-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-05-14 20:16:07" itemprop="dateModified" datetime="2022-05-14T20:16:07+08:00">2022-05-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/RPC/" itemprop="url" rel="index"><span itemprop="name">RPC</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/RPC/Dubbo/" itemprop="url" rel="index"><span itemprop="name">Dubbo</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>从本篇开始就进去关于dubbo 的一系列分析文章，dubbo 本身的一些基础概念和用法在这个系列中不会去讲到，这些通过dubbo 的官网可以了解，平时工作时的使用方法官网也有详细描述。dubbo 系列的文章主要从dubbo 的核心架构 -&gt; 核心机制SPI机制 -&gt; provider 端的启动 -&gt; consumer 端的启动 -&gt; 服务调用全流程，这一套流程来详细分析。</p>
<p>本次就是主要简单说下dubbo 的核心架构还有详细走一遍spi 机制的实现原理，SPI 是dubbo 的核心，没有SPI 就相当于Spirng 没有IOC 和aop。
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/02/20/Dubbo-1/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/11/Zookeeper-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/8a06cd0a8da6a6848b7a0b37b32164b7.jpeg">
      <meta itemprop="name" content="李万青">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茯楚博客">
      <meta itemprop="description" content="苦心人天不负">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 茯楚博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/02/11/Zookeeper-1/" class="post-title-link" itemprop="url">zookeeper源码分析-线程模型与数据流转分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-11 16:40:51" itemprop="dateCreated datePublished" datetime="2022-02-11T16:40:51+08:00">2022-02-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-18 15:24:48" itemprop="dateModified" datetime="2023-03-18T15:24:48+08:00">2023-03-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">中间件</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/Zookeeper/" itemprop="url" rel="index"><span itemprop="name">Zookeeper</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>技术分析开始的第一篇文章还是要简单的说一下它的基本用法和基本概念，然后再说一下这系列文章的大体分析流程。zk 这个系列的文章也不会很多，应该就是三篇基本结束，如果在算上后面的集群的话也就是四篇，不过集群的东西我会在写完并发编程之后再写，暂时zk 主要的源码分析其实就是三部分，主流程启动、三个线程启动、任务链执行。</p>
<p>本次主要是聊一下zk 的基本概念、线程模型还有主流程启动。zk 的基本概念这种东西在度娘上很轻易就能搜到的东西，所以这篇文章的重点就是放在zookeeper 主流程启动时做了些什么，还有它的线程模型是怎样的，和netty 之前有什么区别。那么现在就开始发车了。</p>
<h2 id="zookeeper的基本概念和安装"><a href="#zookeeper的基本概念和安装" class="headerlink" title="zookeeper的基本概念和安装"></a>zookeeper的基本概念和安装</h2><p>说到zookeeper 基本都是想到和dubbo 结合使用，这个是经典的rpc 架构模式，zookeeper 在这个模式里面主要就是被使用为注册中心，就算是目前最流行的spring cloud 组件中的注册中心也有使用zookeeper 的情况。</p>
<p>zk 除了被当做注册中心使用之外，还能做配置中心，分布式锁等等。它本身就是一个很强大的中间件，它的底层代码也是用java 来编写的，它 对Java 也提供了三种客户端：zookeeper 原生的API，Curator，zkClient。zookeeper 原生的API 偏底层不是很好用，一般是用的就是Curator，而Curator 也就是封装了这些API。</p>
<p>说会zk 本身的一些基本概念，我们聊的话，就是从它的来源、数据结构、节点类型三个方面简单的分析一下。</p>
<h3 id="zookeeper的来源"><a href="#zookeeper的来源" class="headerlink" title="zookeeper的来源"></a>zookeeper的来源</h3><p>zookeeper 是Apache 软件基金会的一个软件项目，它为大型分布式计算提供开源的分布式配置服务、同步服务和命名注册。</p>
<p>zookeeper 的架构通过冗余服务实现高可用行（CP）。</p>
<p>zookeeper 的设计目标是将那些复杂且容易出错的分布式一致性服务封住起来，构成一个高效可靠的原语集，并以一系列简单 易用的接口提供给用户使用。</p>
<p>它是一个典型的分布式数据一致性的解决方案，分布式应用程序可以基于它实现诸如数据发布&#x2F;订阅、负载均衡、命名服务、分布式 协调&#x2F;通知、集群管理、Master 选举、分布式锁和分布式队列等功能。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>zookeeper本身是一个树形目录服务（名称空间），非常类似于标准文件系统，key-value 的形式存储。名称 key 由斜线 &#x2F; 分 割的一系列路径元素，zookeeper 名称空间中的每个节点都是由一个路径来标识的。</p>
<p>它的每一个节点可以存储数据，每一个节点还有对应的状态信息。zookeeper 的key 可以理解为：节点的完整路径；value 就是：节点中的数据。</p>
<p><img src="https://liwqtm-blog.oss-cn-shanghai.aliyuncs.com/blog/2022/05/30/13:25:55-06d9baf4151541c3b98e506aab51569d.png" alt="img"></p>
<h3 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h3><p><img src="https://liwqtm-blog.oss-cn-shanghai.aliyuncs.com/blog/2022/05/30/13:26:16-d2afb49540ab4a3d8d2b729c0862b4c6.png" alt="img"></p>
<h3 id="安装于源码下载"><a href="#安装于源码下载" class="headerlink" title="安装于源码下载"></a>安装于源码下载</h3><p>zk 的安装还是比较简单的，从官网下载压缩包，然后解压，再然后就是找到conf 目录下的zoo_sample.cfg 文件，复制粘贴在同级目录下，修改名称为zoo.cfg，同时修改文件中的dataDir 属性，该属性值为zk 存储数据的目录，最后bin 目录下的zkServer，如果是Windows 系统的话就是”.cmd”尾缀的文件启动，如果是Linux 系统的话就是”.sh”尾缀的文件启动。</p>
<p>至于zk 的源码可以在我的CSDN 资源上面下载，地址：<a target="_blank" rel="noopener" href="https://download.csdn.net/download/qq_39339965/80271551?spm=1001.2014.3001.5501">zk源码注释版</a> 。</p>
<h2 id="线程模型（重点）–主从reactor-多线程模型"><a href="#线程模型（重点）–主从reactor-多线程模型" class="headerlink" title="线程模型（重点）–主从reactor 多线程模型"></a>线程模型（重点）–主从reactor 多线程模型</h2><p>zk 的线程模型是重点中的重点，不理解线程模型就没有办法跟代码，线程模型也是面试问到zk 后必须要回答的点，不说废话，先上图。</p>
<p><img src="https://liwqtm-blog.oss-cn-shanghai.aliyuncs.com/blog/2022/05/30/13:28:30-36de86bdd71149ab88fce1cd7ff3d4d9.png" alt="img"></p>
<p>从上图基本可以看到其实和netty 的线程模型基本类似，主从reactor 多线程模型，不同的是zk 不光是主从reactor 多线程模型，它对于部分的内容更加细化，因为它除了网络传输还有很大一部分的业务逻辑处理，下面我先简单的描述一下这幅图的大体流程，后面我们跟过源码之后，再总结全流程。</p>
<ol>
<li>当client 请求过来的时候，先会在acceptThread 线程上通过第一个selector 注册serverSocketChannel，并将信息添加到队列acceptedQueue 中;</li>
<li>然后会在SelectorThread 线程上读取acceptedQueue 中的信息，然后将socketChannel 注册在第二个selector 上监听读写；</li>
<li>当读行为被监听到时，会将信息封装为IOWorkRequest 对象，然后封装为线程对象交给workService 线程池来执行。</li>
</ol>
<p>这就线程模型的一个基本流程，这个还有一些关于对象的封装、线程池的管理、过期检测等等，后面我们看源码的时候会逐一分析到。</p>
<h2 id="zookeeper的主流程启动"><a href="#zookeeper的主流程启动" class="headerlink" title="zookeeper的主流程启动"></a>zookeeper的主流程启动</h2><p>zk 的启动是通过bin 目录下的zkServer.cmd 文件或者zkServer.sh 文件，这两者的区别就是对应着两个不同的操作系统，前者是Windows，后者是Linux，它们的本质的区别就是各种的启动命令不一样，但是调用的程序入口都是QuorumPeerMain 对象。</p>
<p>找到程序入口后，可以直接跟进到QuorumPeerMain 对象的main 方法，再进去其调用的initializeAndRun 方法，这里可以看到zk 的两种不同启动方式，单机启动和集群启动，不过在进入两种启动之前，zk 还需要做清理快照和事务日志。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 开始清理快照和事务日志</span></span><br><span class="line"><span class="comment">  * DatadirCleanupManager包含一个Timer定时器和PurgeTask清理任务。PurgeTask 是基于TimerTask实现的；</span></span><br><span class="line"><span class="comment">  * 首先认知下zookeeper主要存放了两类文件，snapshot和log，snapshot是数据的快照，log是与snapshot关联一致的事务日志</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">DatadirCleanupManager</span> <span class="variable">purgeMgr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatadirCleanupManager</span>(</span><br><span class="line">    config.getDataDir(),</span><br><span class="line">    config.getDataLogDir(),</span><br><span class="line">    config.getSnapRetainCount(),</span><br><span class="line">    config.getPurgeInterval());</span><br><span class="line">purgeMgr.start();</span><br></pre></td></tr></table></figure>

<p>至于是单机启动和集群启动，我们一点一点分析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 判断是否是集群启动还是单机启动</span></span><br><span class="line"><span class="comment">  * 初次运行到这如果报错：</span></span><br><span class="line"><span class="comment">  * 1、添加必要的依赖</span></span><br><span class="line"><span class="comment">  * 2、重新编译zookeeper-jute</span></span><br><span class="line"><span class="comment">  * 必要情况下编译打包安装整个项目(跳过测试)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">if</span> (args.length == <span class="number">1</span> &amp;&amp; config.isDistributed()) &#123;</span><br><span class="line">    <span class="comment">//集群启动</span></span><br><span class="line">    runFromConfig(config);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    LOG.warn(<span class="string">&quot;Either no config or no quorum defined in config, running in standalone mode&quot;</span>);</span><br><span class="line">    <span class="comment">// there is only server in the quorum -- run as standalone</span></span><br><span class="line">    ZooKeeperServerMain.main(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单机启动"><a href="#单机启动" class="headerlink" title="单机启动"></a>单机启动</h3><p>单机启动跟进的就是ZooKeeperServerMain 类的main 方法，然后是initializeAndRun 方法，其余的都重要，最关键的是其中调用的runFromConfig 方法。</p>
<p>runFromConfig 方法就是：根据配置启动运行的具体内容，这里看代码之前，其实我们就可以根据上面的主从reactor 多线程模型中看到，他最重要的内容就是计算出上面三个线程的多少，配置线程池，并启动其线程，至于zk 本身的数据库快照，数据存储本身我们不关注，zk 源码我们主要了解的它的思维、架构模式。</p>
<p>我们这里直接就看对应的源码，如果对于快照初始之类的代码有兴趣可以直接去看我放在CSDN 上的源码（<a target="_blank" rel="noopener" href="https://download.csdn.net/download/qq_39339965/80271551">zk源码</a>）。这里我们直接从runFromConfig 方法的CountDownLatch 对象创建开始看。</p>
<h4 id="CountDownLatch–同步工具类，用于阻塞主线程"><a href="#CountDownLatch–同步工具类，用于阻塞主线程" class="headerlink" title="CountDownLatch–同步工具类，用于阻塞主线程"></a>CountDownLatch–同步工具类，用于阻塞主线程</h4><p>CountDownLatch 对象是一个同步工具类，这里zk 用于阻塞主线程，因为zk 的具体工作基本都是异步线程做的，主线程只用于创建和启动异步线程。这里可以看到主要就是创建了这个对应，并注册了一个监听对象ZooKeeperServerShutdownHandler，这个对象的作用就是当zk 出现状态异常的时候，将CountDownLatch 进行停止，调用的是其countDown 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注册zookeeper服务关闭监听处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">shutdownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">zkServer.registerServerShutdownHandler(<span class="keyword">new</span> <span class="title class_">ZooKeeperServerShutdownHandler</span>(shutdownLatch));</span><br></pre></td></tr></table></figure>

<h4 id="ServerCnxnFactory–主服务的创建和启动"><a href="#ServerCnxnFactory–主服务的创建和启动" class="headerlink" title="ServerCnxnFactory–主服务的创建和启动"></a>ServerCnxnFactory–主服务的创建和启动</h4><p>中间的代码可以略过，我们直接看ServerCnxnFactory 的创建。下面的createFactory 方法代码可以看到，如果我们没有默认配置的话，zk 会默认选择NIO 的服务端NIOServerCnxnFactory 对象，当然我们也可以通过配置来选择Netty 的服务端。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnxnFactory = ServerCnxnFactory.createFactory();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ServerCnxnFactory <span class="title function_">createFactory</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取系统参数：zookeeper.serverCnxnFactory</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">serverCnxnFactoryName</span> <span class="operator">=</span> System.getProperty(ZOOKEEPER_SERVER_CNXN_FACTORY);</span><br><span class="line">    <span class="keyword">if</span> (serverCnxnFactoryName == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果没有配置zookeeper网络IO管理器 则默认采用JAVA NIO</span></span><br><span class="line">        serverCnxnFactoryName = NIOServerCnxnFactory.class.getName();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 可以配置netty,通过系统参数zookeeper.serverCnxnFactory配置如下值:</span></span><br><span class="line"><span class="comment">             * org.apache.zookeeper.server.NettyServerCnxnFactory</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">ServerCnxnFactory</span> <span class="variable">serverCnxnFactory</span> <span class="operator">=</span> (ServerCnxnFactory) Class.forName(serverCnxnFactoryName)</span><br><span class="line">            .getDeclaredConstructor()</span><br><span class="line">            .newInstance();</span><br><span class="line">        LOG.info(<span class="string">&quot;Using &#123;&#125; as server connection factory&quot;</span>, serverCnxnFactoryName);</span><br><span class="line">        <span class="keyword">return</span> serverCnxnFactory;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="type">IOException</span> <span class="variable">ioe</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Couldn&#x27;t instantiate &quot;</span> + serverCnxnFactoryName, e);</span><br><span class="line">        <span class="keyword">throw</span> ioe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当启动完成之后，我们直接用它的configure 方法，进行参数、线程信息的配置。</p>
<p>结合上面的模型图来看，zk 首先创建的是cnxnExpiryQueue 队列和expirerThread 线程，cnxnExpiryQueue 队列后续存放的就是socketChannel 的一些信息，而expirerThread 线程就是来检测这个会话是否过期了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 连接会话过期队列,连接被建立后也会被添加到该队列，由expirerThread不断去检测该队列中的连接是否过期</span></span><br><span class="line"><span class="comment"> * 虽然交ExpiryQueue，但内部维护的是两个Map：elemMap 和 expiryMap</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">cnxnExpiryQueue = <span class="keyword">new</span> <span class="title class_">ExpiryQueue</span>&lt;NIOServerCnxn&gt;(sessionlessCnxnTimeout);</span><br><span class="line">expirerThread = <span class="keyword">new</span> <span class="title class_">ConnectionExpirerThread</span>();<span class="comment">//创建expirerThread 用于检测连接会话是否过期</span></span><br></pre></td></tr></table></figure>

<p>然后这里会根据计算机的CPU核数，来计算出对应的线程数量，这里只要知道就行。</p>
<p>逻辑：当前系统核数除以2后再开根号的整数，最少1个，也就是说我的电脑如果是8核，那么就是8 &#x2F; 2 &#x3D; 4 在开根号 &#x3D; 2个，如果是4核，那么就是1。然后再用这个核数计算出来的数据 * 2 就能得到后面selectorThread 和workService 的线程数量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 求SelectorThread：selector thread,使用系统属性zookeeper.nio.numSelectorThreads配置该类线程数,</span></span><br><span class="line"><span class="comment">         * 默认个数为 Math.sqrt(核心数/2)(至少一个)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">numCores</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();</span><br><span class="line"><span class="comment">// 32 cores sweet spot seems to be 4 selector threads</span></span><br><span class="line">numSelectorThreads = Integer.getInteger(</span><br><span class="line">    ZOOKEEPER_NIO_NUM_SELECTOR_THREADS,</span><br><span class="line">    Math.max((<span class="type">int</span>) Math.sqrt((<span class="type">float</span>) numCores / <span class="number">2</span>), <span class="number">1</span>));</span><br><span class="line"><span class="keyword">if</span> (numSelectorThreads &lt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;numSelectorThreads must be at least 1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * WorkerThread：执行基本的套接字读写(IO操作)</span></span><br><span class="line"><span class="comment">         * 使用系统属性zookeeper.nio.numWorkerThreads配置该类线程数,默认为核心数∗2</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">numWorkerThreads = Integer.getInteger(ZOOKEEPER_NIO_NUM_WORKER_THREADS, <span class="number">2</span> * numCores);</span><br><span class="line">workerShutdownTimeoutMS = Long.getLong(ZOOKEEPER_NIO_SHUTDOWN_TIMEOUT, <span class="number">5000</span>);</span><br></pre></td></tr></table></figure>

<p>接下来就可以直接看到selectorThread 线程的创建，注意：这里只是创建没有启动，这里创建的数量就是上面计算的大小。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;SelectorThread&gt; selectorThreads = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;SelectorThread&gt;();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numSelectorThreads; ++i) &#123;</span><br><span class="line">    selectorThreads.add(<span class="keyword">new</span> <span class="title class_">SelectorThread</span>(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法的最后就是serverSocketChannel 的监听线程的创建，还有serverSocketChann 的端口绑定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel ss;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">listenBacklog = backlog;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 打开一个ServerSocketChannel</span></span><br><span class="line"><span class="comment">         * 绑定端口,设置非阻塞</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="built_in">this</span>.ss = ServerSocketChannel.open();</span><br><span class="line">ss.socket().setReuseAddress(<span class="literal">true</span>);</span><br><span class="line">LOG.info(<span class="string">&quot;binding to port &#123;&#125;&quot;</span>, addr);</span><br><span class="line"><span class="keyword">if</span> (listenBacklog == -<span class="number">1</span>) &#123;</span><br><span class="line">    ss.socket().bind(addr);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ss.socket().bind(addr, listenBacklog);</span><br><span class="line">&#125;</span><br><span class="line">ss.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建AcceptThread，将ServerSocketChannel 注册到该 acceptThread,并监听它的OP_ACCEPT事件</span></span><br><span class="line"><span class="comment"> * acceptThread 线程只用于接收客户端的连接</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">acceptThread = <span class="keyword">new</span> <span class="title class_">AcceptThread</span>(ss, addr, selectorThreads);</span><br></pre></td></tr></table></figure>

<p>当ServerCnxnFactory 的configure 方法结束之后，就是startup 启动方法的调用了。但是这个方法，我们只要关注里面的start 方法调用就行了，其余的数据库会话回复、还有各个组件调用之类的，有兴趣的自己看下就行。</p>
<p>start 方法中首先创建的就是上面configure 方法中没有创建的workerPool 线程池，具体的线程数量也是和selectorThread 的线程数量一样的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (workerPool == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建workerPool,默认是创建了一个线程池，核心线程数是numWorkerThreads=cup核数*2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    workerPool = <span class="keyword">new</span> <span class="title class_">WorkerService</span>(<span class="string">&quot;NIOWorker&quot;</span>, numWorkerThreads, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就是对所有的selectorThread 线程启动了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动所有的SelectorThread</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">for</span> (SelectorThread thread : selectorThreads) &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * State.NEW：hread state for a thread which has not yet started.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (thread.getState() == Thread.State.NEW) &#123;</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后就是启动acceptThread 线程用于连接的监听，还有expirerThread 线程用于socketChannel 的过期检测。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//启动acceptThread开始接收连接</span></span><br><span class="line"><span class="keyword">if</span> (acceptThread.getState() == Thread.State.NEW) &#123;</span><br><span class="line">    acceptThread.start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//启动expirerThread</span></span><br><span class="line"><span class="keyword">if</span> (expirerThread.getState() == Thread.State.NEW) &#123;</span><br><span class="line">    expirerThread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里ServerCnxnFactory 服务的创建和启动就结束了，后续的代码其实我们的关注点就是一个，就是上面说的CountDownLatch 同步工具类的阻塞内容。这里就是调用了提供出来的await 方法进行了阻塞，这样才能保证zk 是启动着，其余的异步线程才能一直运行，只有最后将zk 停止之后，才会运行下面对应的停止逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shutdownLatch.await();<span class="comment">//阻塞等待zookeeper服务关闭或出现内部错误</span></span><br><span class="line"></span><br><span class="line">shutdown();</span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>zk 的主流程的启动说白了就是对于主从reactor 多线程模型 中的几个线程的创建、配置、启动，还有就是传输服务端的选择是NIO 还是Netty，至于它本身的数据配置还有日志服务还有各个组件反倒是其次。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李万青</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
